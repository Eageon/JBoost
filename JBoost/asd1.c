/*************************************
This program can be used to evaluate a jboost-trained classifier on new data.  
The code contains a single procedure:

  double predict(void **attr, double *ret)

The first argument attr is an array of pointers corresponding to the
attributes specified in the spec file.  Thus, if attribute i is text,
then attr[i] must be a char array; if attribute i is a number, then
*attr[i] must be a double; and if attribute i is finite, then *attr[i]
must be an int containing the index of the chosen value.  An undefined
attribute is indicated by setting attr[i] to NULL.

Specifically, these pointers are:

     index    attr.type    data.type   name
   ------------------------------------------

The second argument ret is a pointer to an array of k doubles, where k
is the number of classes.  The scores for each of the k classes will
be stored in this array.  If ret is NULL, then no scores are stored.
In any case, predict returns the score for class 0 (=ret[0]).

These scores correspond to the classes as follows:

            index       class name
           ------------------------
               0        +1
               1        -1

This classifier was automatically generated by jboost on
Fri Apr 06 17:04:49 CST 2012.
*************************************/
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <values.h>
typedef double Prediction_t;
#define reset_pred()  {p = 0.0;}
#define add_pred(X) {p += (X);}
#define finalize_pred()  ((r) ? (r[1] = p , r[0] = -p) : -p)
#define defined_attr(X)  (attr[X])
#define int_attr(X)      (*((int *) attr[X]))
#define attr_contains_token(X,Y) (tokens[X][Y])
#define double_attr(X)   (*((double *) attr[X]))

#define WHITE_CHARS   " \t\n"
typedef struct hash_table_entry_s {
  char *key;
  int id;
  struct hash_table_entry_s *next;
} HashTableEntry_t;
static char *keys[] = {
};
#define num_keys  (0)
static HashTableEntry_t **hash_table = NULL;
#define hash_table_size  (1031)
static char *tokens[1];
static int text_attr[] = {};
#define num_text_attr  (0)
static char **text_patterns[] = {
};

static char **words;
static int num_words;
static int cur_word;
static char *pattern;
static int pattern_len;

static void set_pattern(int n, char **m_w, char *pat) {
  words = m_w;
  pattern = pat;
  cur_word = 0;
  num_words = n;
  pattern_len = strlen(pat);
}

#define more_tokens()  (cur_word <= num_words - pattern_len)

#define ADD_CHAR(S)  { \
  if (c >= buffer_size) { \
    buffer_size = 2 * buffer_size + 1; \
    buffer = (char *) realloc(buffer, buffer_size * sizeof(char)); \
  } \
  buffer[c++] = (S); \
}

static char *next_token(void) {
  static char *buffer = NULL;
  static int buffer_size = 0;
  int i, c;
  char *s;

  c = 0;
  for (s = pattern; *s; s++)
    ADD_CHAR(*s);

  for (i = 0; i < pattern_len; i++) {
    if (pattern[i] == '1') {
      ADD_CHAR(' ');
      for (s = words[cur_word + i]; *s; s++)
	ADD_CHAR(*s);
    }
  }
  ADD_CHAR('\0');
  cur_word++;
  return buffer;
}

static int
hash(char *s) {
  static int *coef = NULL;
  static int max_len = 0;
  int len = strlen(s);
  int i, h;

  if (len > max_len) {
    i = max_len;
    max_len = 2 * len;
    coef = (int *) realloc(coef, max_len * sizeof(int));
    for (; i < max_len; i++)
      coef[i] = random() % hash_table_size;
  }

  h = 0;
  for (i = 0; i < len; i++) {
     if (h >= MAXINT - (hash_table_size - 1) * 255)
       h = h % hash_table_size;
     h += coef[i] * s[i];
  }
  return (h % hash_table_size);
}

double predict(void **attr, double *r) {
  int i, j, h, a;
  HashTableEntry_t *entry;
  char *s;
  static char **words = NULL;
  static int max_word_list_size = 0;
  int num_words;
  static char *buffer = NULL;
  static int buffer_size = 0;
  char **pat;

  Prediction_t p;

  if (!hash_table) {
    hash_table = (HashTableEntry_t **)
      malloc(hash_table_size * sizeof(HashTableEntry_t *));
    for (i = 0; i < hash_table_size; i++)
      hash_table[i] = NULL;
    for (i = 0; i < num_keys; i++) {
      h = hash(keys[i]);
      entry = (HashTableEntry_t *) malloc(sizeof(HashTableEntry_t));
      entry->key = keys[i];
      entry->id = i;
      entry->next = hash_table[h];
      hash_table[h] = entry;
    }
    for (i = 0; i < num_text_attr; i++)
      tokens[text_attr[i]] = (char *) malloc(num_keys * sizeof(char));
  }

  for (i = 0; i < num_text_attr; i++) {
    a = text_attr[i];
    if (!defined_attr(a))
      continue;
    for (j = 0; j < num_keys; j++)
      tokens[a][j] = 0;

    while (strlcpy(buffer, attr[a], buffer_size) >= buffer_size) {
      buffer_size = 2 * strlen(attr[a]);
      buffer = (char *) realloc(buffer, (buffer_size+1) * sizeof(char));
    }
    num_words = 0;
    for (s = strtok(buffer, WHITE_CHARS); s; s = strtok(NULL, WHITE_CHARS)) {
      if (num_words >= max_word_list_size) {
        max_word_list_size = 2 * max_word_list_size + 1;
        words = (char **) realloc(words, max_word_list_size * sizeof(char *));
      }
      words[num_words++] = s;
    }
    for (pat = text_patterns[i]; *pat; pat++) {
      set_pattern(num_words, words, *pat);
      while (more_tokens()) {
        s = next_token();
        for (entry = hash_table[hash(s)]; entry; entry = entry->next)
          if (!strcmp(entry->key, s)) {
            tokens[a][entry->id] = 1;
            break;
          }
        }
      }
  }

  reset_pred();

  add_pred(   /* R */
             -12.749460048194328);
  if (defined_attr(0)) {  /* R.0 */
    if (double_attr(0) <= 177.0) {
      add_pred(   /* R.0:0 */
                 -2.004376634962274);
    } else {
      add_pred(   /* R.0:1 */
                 -2.3567817736620276);
    }
  }
  if (defined_attr(29)) {  /* R.1 */
    if (double_attr(29) <= 3048.5) {
      add_pred(   /* R.1:0 */
                 -1.338593393492093);
    } else {
      add_pred(   /* R.1:1 */
                 -0.6200385657309491);
    }
  }
  if (defined_attr(1)) {  /* R.2 */
    if (double_attr(1) <= -393.5) {
      add_pred(   /* R.2:0 */
                 -0.8486933874746179);
    } else {
      add_pred(   /* R.2:1 */
                 -1.2644752669813994);
    }
  }
  if (defined_attr(48)) {  /* R.3 */
    if (double_attr(48) <= 403.0) {
      add_pred(   /* R.3:0 */
                 -1.376837492407414);
    } else {
      add_pred(   /* R.3:1 */
                 -0.41640583184316987);
    }
  }

  return finalize_pred();
}

